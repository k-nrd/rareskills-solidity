
/** 
 *  SUM_ARRAY HUFF EXERCISE
 *
 * In this puzzle, the task is to simulate an array in Huff using the "exact" storage pattern as solidity. Expected functions can; 
 *      - Push numbers onto a array, 
 *      - Pop the last index from the array,
 *      - View what's stored at an index, 
 *      - Gets the length of the array, 
 *      - Write to an index if it is valid.
 *
 *      - Writes and reads outside of length revert. 
 *      - Popping off a zero length array reverts.
 *
 *  NOTICE: The contract should revert when an unrecognized function is called
 */

#define function pushh(uint256 num) payable returns()
#define function popp() payable returns()
#define function read(uint256 index) payable returns(uint256)
#define function length() payable returns(uint256)
#define function write(uint256 index, uint256 num) payable returns()

#define error OutOfBounds()
#define error ZeroArray()

#define constant SIZE_SLOT = 0x00

#define macro LENGTH() = takes(0) returns(0) {
  [SIZE_SLOT] sload         // [array_length]
  0x00 mstore               // []
  0x20 0x00 return
}

#define macro READ() = takes(0) returns(0) {
  [SIZE_SLOT] sload         // [array_length]
  dup1 iszero fail jumpi    // bail if length is zero, [length]

  0x04 calldataload         // [idx, array_length]
  0x01 dup3 sub             // [length-1, idx, array_length]
  dup2 gt fail jumpi        // out of bounds if idx > length - 1 [idx, array_length]

  0x20 mul                  // [abs_idx, length]
  0x20 add                  // [rel_idx, length] (take into account size slot)
  sload                     // [value, length]
  0x00 mstore 
  0x20 0x00 return

  fail:
    __ERROR(OutOfBounds)    // [panic_error_selector]
    0x00 mstore             // []
    0x04 0x00 revert
}

#define macro WRITE() = takes(0) returns(0) {
  [SIZE_SLOT] sload         // [array_length]
  dup1 iszero fail jumpi    // bail if length is zero, [length]

  0x04 calldataload         // [idx, length]
  0x01 dup3 sub             // [length-1, idx, length]
  dup2 gt fail jumpi        // out of bounds if idx > length - 1 [idx, length]

  0x20 mul             // [s_ptr, length]
  0x20 add                  // [rel_idx, length] (take into account size slot)
  0x24 calldataload         // [value, rel_idx, length]
  swap1                     // [rel_idx, value, length]
  sstore                    // [length]

  0x00 0x00 mstore          // []
  0x00 0x00 return

  fail:
    __ERROR(OutOfBounds)    // [panic_error_selector]
    0x00 mstore             // []
    0x04 0x00 revert
}

#define macro PUSHH() = takes(0) returns(0) {
  [SIZE_SLOT] sload         // [array_length]
  dup1 0x20 mul             // [s_ptr, length]
  0x20 add                  // take into acct size slot 
  0x04 calldataload         // [value, s_ptr, length]
  swap1                     // [s_ptr, value, length]
  sstore                    // [length]
  0x01 add                  // [length+1]
  [SIZE_SLOT] sstore        // []

  0x00 0x00 mstore               // []
  0x00 0x00 return
}

#define macro POPP() = takes(0) returns(0) {
  [SIZE_SLOT] sload         // [array_length]
  dup1 iszero fail jumpi    // can't pop array 0

  dup1 0x20 mul             // [s_ptr, length]
  0x00                      // [0, s_ptr, length]
  swap1                     // [s_ptr, 0, length] 
  sstore                    // set s_ptr to 0 [length] 
  0x01                      // [0x01, length]
  swap1                     // [length, 0x01] 
  sub                       // [length-1] 
  [SIZE_SLOT] sstore        // store new length

  0x00 0x00 mstore
  0x00 0x00 return

  fail:
    __ERROR(ZeroArray)      // [panic_error_selector]
    0x00 mstore             // [panic_code]
    0x04 0x00 revert
}

#define macro MAIN() = takes(0) returns(0) {
  0x00 calldataload           // [calldata @ 0x00]
  0xe0 shr                    // [func_sig]

  dup1 __FUNC_SIG(length) eq length jumpi
  dup1 __FUNC_SIG(read) eq read jumpi
  dup1 __FUNC_SIG(write) eq write jumpi
  dup1 __FUNC_SIG(pushh) eq pushh jumpi
  __FUNC_SIG(popp) eq popp jumpi

  0x00 0x00 revert

  length:
    LENGTH()
  read:
    READ()
  write:
    WRITE()
  pushh:
    PUSHH()
  popp:
    POPP()
}
